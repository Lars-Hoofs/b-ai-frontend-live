import React, { useState, useEffect, useRef } from 'react';
import { WidgetConfig } from './AdvancedWidgetEditor';

export function InteractiveChatPreview({ config, isOpen, setIsOpen, isPreview = false }: {
  config: WidgetConfig,
  isOpen: boolean,
  setIsOpen: (v: boolean) => void,
  isPreview?: boolean
}) {
  const [html, setHtml] = useState<string>('');
  const iframeRef = useRef<HTMLIFrameElement>(null);

  useEffect(() => {
    // Generate the exact HTML that the user will see, using the backend engine
    const fetchPreview = async () => {
      try {
        const res = await fetch('/api/widgets/preview-html', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(config),
        });

        if (res.ok) {
          let injectedHtml = await res.text();

          // To make the preview interactive in the iframe, we also need to inject the loader script logic
          // However, since it's just a preview, we inject a minimal script to handle open/close 
          // to demonstrate how it feels.
          const previewScript = `
            <script>
               document.addEventListener('DOMContentLoaded', () => {
                 const bubble = document.getElementById('ai-chat-bubble');
                 const chatWindow = document.getElementById('ai-chat-window');
                 const closeBtn = document.getElementById('ai-chat-close');
                 
                 // Sync initial state
                 if (${isOpen}) {
                    if (chatWindow) chatWindow.style.display = 'flex';
                    if (bubble) bubble.style.display = 'none';
                 } else {
                    if (chatWindow) chatWindow.style.display = 'none';
                    if (bubble) bubble.style.display = 'flex';
                 }

                 if (bubble) {
                   bubble.addEventListener('click', () => {
                     chatWindow.style.display = 'flex';
                     bubble.style.display = 'none';
                     window.parent.postMessage({ type: 'WIDGET_TOGGLE', isOpen: true }, '*');
                   });
                 }
                 if (closeBtn) {
                   closeBtn.addEventListener('click', () => {
                     chatWindow.style.display = 'none';
                     bubble.style.display = 'flex';
                     window.parent.postMessage({ type: 'WIDGET_TOGGLE', isOpen: false }, '*');
                   });
                 }
               });
            </script>
          `;

          setHtml(injectedHtml + previewScript);
        }
      } catch (e) {
        console.error("Failed to load preview", e);
      }
    };

    // Debounce preview updates slightly to avoid flashing on every keystroke
    const debounce = setTimeout(() => {
      fetchPreview();
    }, 300);

    return () => clearTimeout(debounce);
  }, [config, isOpen]); // Also re-render if isOpen explicitly changes from outside

  // Listen to messages from iframe to sync isOpen state
  useEffect(() => {
    const handleMessage = (e: MessageEvent) => {
      if (e.data?.type === 'WIDGET_TOGGLE') {
        setIsOpen(e.data.isOpen);
      }
    };
    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, [setIsOpen]);

  // Position styles for the iframe container
  const positionStyles: React.CSSProperties = {
    position: isPreview ? 'absolute' : 'fixed',
    zIndex: isPreview ? 10 : (config.zIndex || 999999),
    width: '100%',
    height: '100%',
    pointerEvents: 'none', // Let clicks pass through except on the iframe content
  };

  const offset = { x: config.offsetX || 20, y: config.offsetY || 20 };

  switch (config.position) {
    case 'bottom-right':
      positionStyles.bottom = 0;
      positionStyles.right = 0;
      break;
    case 'bottom-left':
      positionStyles.bottom = 0;
      positionStyles.left = 0;
      break;
    case 'top-right':
      positionStyles.top = 0;
      positionStyles.right = 0;
      break;
    case 'top-left':
      positionStyles.top = 0;
      positionStyles.left = 0;
      break;
    // ... we don't need to position the iframe itself to the exact offset, 
    // because the HTML generated by the renderer ALREADY handles its own absolute positioning!
    // So the iframe just needs to be full screen, full transparent, with pointer-events none on the body,
    // and let the internal CSS place it correctly.
  }

  return (
    <div style={{ position: 'absolute', inset: 0, pointerEvents: 'none', zIndex: 10 }}>
      <iframe
        ref={iframeRef}
        srcDoc={html}
        style={{ width: '100%', height: '100%', border: 'none', pointerEvents: 'auto' }}
        title="Widget Preview"
      />
    </div>
  );
}
